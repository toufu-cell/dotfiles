# 競技プログラミング問題分析スキル

問題を深く分析し、複数のアルゴリズム候補を比較検討します。

## 目的

- 問題の本質的な構造を把握
- 複数の解法候補を列挙・比較
- 最適なアルゴリズムの選定根拠を明確化

## 問題情報

**【問題URL/出典】**: {{problem_source}}
**【難易度】**: {{difficulty}}

## 分析フレームワーク

### 1. 問題の分類

```
【問題カテゴリ】:
□ 探索系 (全探索, 二分探索, 深さ優先, 幅優先)
□ 最適化系 (DP, 貪欲法)
□ グラフ系 (最短経路, 連結性, 木)
□ 数学系 (整数論, 組合せ, 確率)
□ 文字列系 (パターンマッチ, 構文解析)
□ データ構造系 (優先度付きキュー, セグ木, Union-Find)
□ 幾何系 (座標, 距離, 交差判定)
□ ゲーム系 (Grundy数, ミニマックス)
□ 構築系 (条件を満たす例の構成)
□ インタラクティブ

【サブカテゴリ】: [より詳細な分類]
```

### 2. 制約分析

```
【制約一覧】:
| 変数 | 範囲 | 許容計算量 |
|------|------|-----------|
| N    | [範囲] | O(?) |
| M    | [範囲] | O(?) |
| ...  | ...    | ...  |

【計算量早見表】:
- 10^9 操作 ≈ 1秒 (目安)
- N ≤ 10   → O(N!)       可能
- N ≤ 20   → O(2^N)      可能
- N ≤ 100  → O(N^3)      可能
- N ≤ 3000 → O(N^2)      可能
- N ≤ 10^5 → O(N log N)  必要
- N ≤ 10^6 → O(N)        必要
- N ≤ 10^8 → O(log N), O(1) 必要
```

### 3. アルゴリズム候補の列挙

各候補について以下を分析:

```
【候補1】: [アルゴリズム名]
- 計算量: O(?)
- 空間量: O(?)
- 実装難易度: ★☆☆〜★★★
- 適用条件: [このアルゴリズムが使える条件]
- 注意点: [実装時の罠や考慮事項]
- 採用判定: ◎(最適) / ○(可能) / △(厳しい) / ×(不可)

【候補2】: [アルゴリズム名]
...
```

### 4. 類似問題パターン

```
【類似パターン】:
- [パターン名]: [説明]
  - 典型問題: [AtCoder/paiza の類似問題]
  - 解法のキーポイント: [重要な考え方]

【このパターンの定石】:
1. [ステップ1]
2. [ステップ2]
3. ...
```

### 5. 解法の比較表

```
| 解法 | 時間計算量 | 空間計算量 | 実装難易度 | 判定 |
|------|-----------|-----------|-----------|------|
| [解法1] | O(?) | O(?) | ★☆☆ | [判定] |
| [解法2] | O(?) | O(?) | ★★☆ | [判定] |
| [解法3] | O(?) | O(?) | ★★★ | [判定] |

【推奨解法】: [選定結果]
【選定理由】: [詳細な理由]
```

### 6. 実装方針

```
【実装のポイント】:
1. [重要ポイント1]
2. [重要ポイント2]
3. ...

【罠・落とし穴】:
- [よくあるミス1]
- [よくあるミス2]
- ...

【デバッグ戦略】:
- [デバッグ方法1]
- [デバッグ方法2]
```

## 典型アルゴリズム知識ベース

### 探索系

```
【全探索】
- 適用: 状態空間が小さい (N ≤ 10^6)
- 計算量: O(N) 〜 O(N^2)
- パターン: ループ, 再帰, bit全探索

【二分探索】
- 適用: 単調性がある, ソート済み
- 計算量: O(log N)
- パターン: 境界探索, 答えで二分探索

【BFS/DFS】
- 適用: グラフ探索, 状態遷移
- 計算量: O(V + E)
- パターン: 最短距離, 連結判定, 経路探索
```

### 最適化系

```
【動的計画法 (DP)】
- 適用: 最適部分構造, 重複部分問題
- 計算量: O(状態数 × 遷移数)
- パターン: ナップサック, 区間DP, 桁DP, 木DP

【貪欲法】
- 適用: 局所最適 = 大域最適
- 計算量: O(N) 〜 O(N log N)
- パターン: ソート後に処理, 優先度付きキュー
```

### グラフ系

```
【最短経路】
- Dijkstra: 非負重み, O((V+E) log V)
- Bellman-Ford: 負重み可, O(VE)
- Warshall-Floyd: 全点対, O(V^3)

【木・連結性】
- Union-Find: 連結判定, O(α(N))
- LCA: 最小共通祖先, O(log N)
- 木DP: 木上の数え上げ/最適化
```

## 出力形式

1. **問題分類**: カテゴリと特徴
2. **制約分析**: 許容計算量の導出
3. **候補解法**: 複数の解法の比較
4. **推奨解法**: 最適解法と理由
5. **実装方針**: 具体的な実装指針

## 次のステップ

- 実装に進む場合: `/cp-solve` で完全なコード生成
- さらに最適化する場合: `/cp-optimize` でTLE/MLE対策
